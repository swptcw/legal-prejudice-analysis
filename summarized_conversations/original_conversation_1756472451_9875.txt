{'role': 'assistant', 'content': 'Now, let\'s create the webhooks routes:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/routes/webhooks.py">\n"""\nRoutes for webhook management\n"""\n\nimport datetime\nimport uuid\nimport hmac\nimport hashlib\nimport json\nfrom flask import Blueprint, jsonify, request, current_app, g\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom werkzeug.exceptions import NotFound, BadRequest, Forbidden\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom models import Webhook, WebhookDelivery\nfrom utils.auth import require_api_key\nfrom utils.validation import validate_webhook_data\nfrom utils.events import register_webhook_handler\n\n# Create blueprint\nwebhooks_bp = Blueprint(\'webhooks\', __name__)\n\n# Initialize rate limiter\nlimiter = Limiter(key_func=get_remote_address)\n\n@webhooks_bp.route(\'\', methods=[\'POST\'])\n@require_api_key\ndef register_webhook():\n    """Register a new webhook"""\n    try:\n        # Validate request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        errors = validate_webhook_data(data)\n        if errors:\n            return jsonify({"errors": errors}), 400\n        \n        # Generate webhook ID and hash secret\n        webhook_id = f"wh_{str(uuid.uuid4())[:8]}"\n        timestamp = datetime.datetime.utcnow()\n        \n        # Hash the secret\n        secret = data["secret"]\n        secret_hash = hashlib.sha256(secret.encode(\'utf-8\')).hexdigest()\n        \n        # Create webhook record\n        webhook = Webhook(\n            webhook_id=webhook_id,\n            target_url=data["target_url"],\n            events=json.dumps(data["events"]),\n            description=data.get("description", ""),\n            secret_hash=secret_hash,\n            active=data.get("active", True),\n            content_type=data.get("content_type", "application/json"),\n            created_at=timestamp,\n            updated_at=timestamp\n        )\n        \n        # Save to database\n        g.db_session.add(webhook)\n        g.db_session.commit()\n        \n        # Register webhook handler\n        register_webhook_handler(webhook)\n        \n        # Return response (without secret hash)\n        return jsonify({\n            "webhook_id": webhook_id,\n            "target_url": webhook.target_url,\n            "events": json.loads(webhook.events) if isinstance(webhook.events, str) else webhook.events,\n            "description": webhook.description,\n            "active": webhook.active,\n            "content_type": webhook.content_type,\n            "created_at": webhook.created_at.isoformat()\n        }), 201\n        \n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error registering webhook: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error registering webhook: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@webhooks_bp.route(\'\', methods=[\'GET\'])\n@require_api_key\ndef list_webhooks():\n    """List all webhooks"""\n    try:\n        # Query webhooks\n        webhooks = g.db_session.query(Webhook).all()\n        \n        # Convert to dictionaries (without secret hash)\n        webhook_list = []\n        for webhook in webhooks:\n            webhook_dict = {\n                "webhook_id": webhook.webhook_id,\n                "target_url": webhook.target_url,\n                "events": json.loads(webhook.events) if isinstance(webhook.events, str) else webhook.events,\n                "description": webhook.description,\n                "active": webhook.active,\n                "content_type": webhook.content_type,\n                "created_at": webhook.created_at.isoformat()\n            }\n            webhook_list.append(webhook_dict)\n        \n        return jsonify({\n            "webhooks": webhook_list\n        }), 200\n        \n    except Exception as e:\n        current_app.logger.exception(f"Error listing webhooks: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@webhooks_bp.route(\'/<webhook_id>\', methods=[\'GET\'])\n@require_api_key\ndef get_webhook(webhook_id):\n    """Get a specific webhook"""\n    try:\n        # Query webhook\n        webhook = g.db_session.query(Webhook).filter_by(webhook_id=webhook_id).first()\n        if not webhook:\n            raise NotFound(f"Webhook {webhook_id} not found")\n        \n        # Get delivery statistics\n        total_deliveries = g.db_session.query(WebhookDelivery).filter_by(webhook_id=webhook.id).count()\n        successful_deliveries = g.db_session.query(WebhookDelivery).filter_by(\n            webhook_id=webhook.id,\n            status="delivered"\n        ).count()\n        \n        success_rate = successful_deliveries / total_deliveries if total_deliveries > 0 else 0\n        \n        # Get last successful delivery\n        last_successful = g.db_session.query(WebhookDelivery).filter_by(\n            webhook_id=webhook.id,\n            status="delivered"\n        ).order_by(WebhookDelivery.delivered_at.desc()).first()\n        \n        # Convert to dictionary (without secret hash)\n        webhook_dict = {\n            "webhook_id": webhook.webhook_id,\n            "target_url": webhook.target_url,\n            "events": json.loads(webhook.events) if isinstance(webhook.events, str) else webhook.events,\n            "description": webhook.description,\n            "active": webhook.active,\n            "content_type": webhook.content_type,\n            "created_at": webhook.created_at.isoformat(),\n            "updated_at": webhook.updated_at.isoformat(),\n            "delivery_success_rate": success_rate,\n            "total_deliveries": total_deliveries,\n            "successful_deliveries": successful_deliveries,\n            "last_successful_delivery": last_successful.delivered_at.isoformat() if last_successful else None\n        }\n        \n        return jsonify(webhook_dict), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving webhook: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@webhooks_bp.route(\'/<webhook_id>\', methods=[\'PUT\'])\n@require_api_key\ndef update_webhook(webhook_id):\n    """Update a webhook"""\n    try:\n        # Query webhook\n        webhook = g.db_session.query(Webhook).filter_by(webhook_id=webhook_id).first()\n        if not webhook:\n            raise NotFound(f"Webhook {webhook_id} not found")\n        \n        # Get request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        # Update webhook fields\n        timestamp = datetime.datetime.utcnow()\n        updated = False\n        \n        if "target_url" in data:\n            webhook.target_url = data["target_url"]\n            updated = True\n        \n        if "events" in data:\n            if not isinstance(data["events"], list):\n                raise BadRequest("Events must be an array")\n            webhook.events = json.dumps(data["events"])\n            updated = True\n        \n        if "description" in data:\n            webhook.description = data["description"]\n            updated = True\n        \n        if "active" in data:\n            webhook.active = bool(data["active"])\n            updated = True\n        \n        if "content_type" in data:\n            webhook.content_type = data["content_type"]\n            updated = True\n        \n        if "secret" in data:\n            # Hash the new secret\n            secret = data["secret"]\n            webhook.secret_hash = hashlib.sha256(secret.encode(\'utf-8\')).hexdigest()\n            updated = True\n        \n        if updated:\n            webhook.updated_at = timestamp\n            g.db_session.commit()\n            \n            # Re-register webhook handler with updated configuration\n            register_webhook_handler(webhook)\n        \n        # Convert to dictionary (without secret hash)\n        webhook_dict = {\n            "webhook_id": webhook.webhook_id,\n            "target_url": webhook.target_url,\n            "events": json.loads(webhook.events) if isinstance(webhook.events, str) else webhook.events,\n            "description": webhook.description,\n            "active": webhook.active,\n            "content_type": webhook.content_type,\n            "created_at": webhook.created_at.isoformat(),\n            "updated_at": webhook.updated_at.isoformat()\n        }\n        \n        return jsonify(webhook_dict), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error updating webhook: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error updating webhook: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@webhooks_bp.route(\'/<webhook_id>\', methods=[\'DELETE\'])\n@require_api_key\ndef delete_webhook(webhook_id):\n    """Delete a webhook"""\n    try:\n        # Query webhook\n        webhook = g.db_session.query(Webhook).filter_by(webhook_id=webhook_id).first()\n        if not webhook:\n            raise NotFound(f"Webhook {webhook_id} not found")\n        \n        # Delete webhook\n        timestamp = datetime.datetime.utcnow()\n        g.db_session.delete(webhook)\n        g.db_session.commit()\n        \n        return jsonify({\n            "webhook_id": webhook_id,\n            "deleted": True,\n            "deleted_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error deleting webhook: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error deleting webhook: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@webhooks_bp.route(\'/<webhook_id>/deliveries\', methods=[\'GET\'])\n@require_api_key\ndef list_webhook_deliveries(webhook_id):\n    """List all deliveries for a webhook"""\n    try:\n        # Query webhook\n        webhook = g.db_session.query(Webhook).filter_by(webhook_id=webhook_id).first()\n        if not webhook:\n            raise NotFound(f"Webhook {webhook_id} not found")\n        \n        # Get query parameters\n        page = int(request.args.get(\'page\', 1))\n        per_page = min(int(request.args.get(\'per_page\', 20)), 100)  # Limit to 100 items per page\n        status = request.args.get(\'status\')\n        \n        # Build query\n        query = g.db_session.query(WebhookDelivery).filter_by(webhook_id=webhook.id)\n        \n        # Apply filters\n        if status:\n            query = query.filter(WebhookDelivery.status == status)\n        \n        # Count total\n        total = query.count()\n        \n        # Paginate\n        query = query.order_by(WebhookDelivery.created_at.desc())\n        query = query.offset((page - 1) * per_page).limit(per_page)\n        \n        # Execute query\n        deliveries = query.all()\n        \n        # Convert to dictionaries\n        delivery_list = []\n        for delivery in deliveries:\n            delivery_dict = {\n                "delivery_id": delivery.delivery_id,\n                "event_id": delivery.event_id,\n                "event_type": delivery.event_type,\n                "status": delivery.status,\n                "response_code": delivery.response_code,\n                "response_body": delivery.response_body,\n                "error": delivery.error,\n                "retry_count": delivery.retry_count,\n                "created_at": delivery.created_at.isoformat(),\n                "updated_at": delivery.updated_at.isoformat(),\n                "delivered_at": delivery.delivered_at.isoformat() if delivery.delivered_at else None\n            }\n            delivery_list.append(delivery_dict)\n        \n        return jsonify({\n            "webhook_id": webhook_id,\n            "deliveries": delivery_list,\n            "page": page,\n            "per_page": per_page,\n            "total": total,\n            "pages": (total + per_page - 1) // per_page  # Ceiling division\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except ValueError as e:\n        return jsonify({"error": "Invalid pagination parameters"}), 400\n    except Exception as e:\n        current_app.logger.exception(f"Error listing webhook deliveries: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@webhooks_bp.route(\'/test\', methods=[\'POST\'])\n@require_api_key\ndef test_webhook():\n    """Send a test webhook"""\n    try:\n        # Validate request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        required_fields = ["target_url", "event"]\n        for field in required_fields:\n            if field not in data:\n                raise BadRequest(f"Missing required field: {field}")\n        \n        target_url = data["target_url"]\n        event_type = data["event"]\n        include_sample_data = data.get("include_sample_data", True)\n        \n        # Generate test event ID\n        test_id = f"test_{str(uuid.uuid4())[:8]}"\n        timestamp = datetime.datetime.utcnow()\n        \n        # Create sample payload\n        if include_sample_data:\n            if event_type == "assessment.created":\n                payload = {\n                    "id": "evt_test",\n                    "event": "assessment.created",\n                    "created_at": timestamp.isoformat(),\n                    "api_version": "v1",\n                    "data": {\n                        "assessment_id": "PRF-2025-TEST",\n                        "case_name": "Test Case",\n                        "judge_name": "Test Judge",\n                        "assessor_name": "Test Assessor",\n                        "assessment_date": timestamp.strftime("%Y-%m-%d"),\n                        "case_id": "CASE-TEST",\n                        "case_management_system_id": "CMS-TEST",\n                        "status": "created"\n                    }\n                }\n            elif event_type == "result.calculated":\n                payload = {\n                    "id": "evt_test",\n                    "event": "result.calculated",\n                    "created_at": timestamp.isoformat(),\n                    "api_version": "v1",\n                    "data": {\n                        "assessment_id": "PRF-2025-TEST",\n                        "overall_score": 18,\n                        "risk_level": "High",\n                        "category_scores": {\n                            "relationship": 17,\n                            "conduct": 12,\n                            "contextual": 9\n                        },\n                        "high_risk_factors": [\n                            {\n                                "id": "financial-direct",\n                                "name": "Direct financial interest",\n                                "score": 20\n                            }\n                        ],\n                        "recommendations": [\n                            "File a motion to recuse/disqualify or for disclosure of potential conflicts",\n                            "Consider requesting a hearing on prejudice concerns",\n                            "Develop detailed documentation of all prejudice indicators",\n                            "Implement strategic adjustments to case presentation",\n                            "Prepare record for potential appeal on prejudice grounds"\n                        ],\n                        "calculated_at": timestamp.isoformat()\n                    }\n                }\n            else:\n                payload = {\n                    "id": "evt_test",\n                    "event": event_type,\n                    "created_at": timestamp.isoformat(),\n                    "api_version": "v1",\n                    "data": {\n                        "message": "This is a test webhook",\n                        "timestamp": timestamp.isoformat()\n                    }\n                }\n        else:\n            payload = {\n                "id": "evt_test",\n                "event": event_type,\n                "created_at": timestamp.isoformat(),\n                "api_version": "v1",\n                "data": {\n                    "message": "This is a test webhook",\n                    "timestamp": timestamp.isoformat()\n                }\n            }\n        \n        # Generate signature\n        test_secret = "test_webhook_secret"\n        signature_payload = f"{int(timestamp.timestamp())}.{json.dumps(payload)}"\n        signature = hmac.new(\n            test_secret.encode(\'utf-8\'),\n            signature_payload.encode(\'utf-8\'),\n            hashlib.sha256\n        ).hexdigest()\n        \n        # Prepare headers\n        headers = {\n            "Content-Type": "application/json",\n            "X-Prejudice-Signature": f"sha256={signature}",\n            "X-Prejudice-Timestamp": str(int(timestamp.timestamp())),\n            "X-Prejudice-Event": event_type,\n            "X-Prejudice-Webhook-ID": "wh_test",\n            "User-Agent": "PrejudiceRiskCalculator-Webhook/1.0"\n        }\n        \n        # In a real implementation, this would send an HTTP request\n        # For now, we\'ll simulate a successful delivery\n        \n        # Return response\n        return jsonify({\n            "test_id": test_id,\n            "target_url": target_url,\n            "event": event_type,\n            "status": "delivered",\n            "response_code": 200,\n            "response_body": \'{"status":"received"}\',\n            "request_headers": headers,\n            "request_body": json.dumps(payload),\n            "created_at": timestamp.isoformat(),\n            "delivered_at": timestamp.isoformat()\n        }), 200\n        \n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except Exception as e:\n        current_app.logger.exception(f"Error testing webhook: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n</create-file>\n</function_calls>', 'tool_calls': None}