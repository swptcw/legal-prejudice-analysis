{'role': 'assistant', 'content': 'Now, let\'s create the results routes file:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/routes/results.py">\n"""\nRoutes for risk calculation results\n"""\n\nimport datetime\nimport json\nfrom flask import Blueprint, jsonify, request, current_app, g\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom werkzeug.exceptions import NotFound, BadRequest\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom models import Assessment, Factor, Result, RiskLevel, FactorDefinition\nfrom utils.auth import require_api_key\nfrom utils.events import trigger_event\n\n# Create blueprint\nresults_bp = Blueprint(\'results\', __name__)\n\n# Initialize rate limiter\nlimiter = Limiter(key_func=get_remote_address)\n\ndef calculate_risk_score(assessment):\n    """Calculate risk scores based on factor ratings"""\n    # Get all factors for this assessment\n    factors = g.db_session.query(Factor).filter_by(assessment_id=assessment.id).all()\n    \n    # Get factor definitions for names\n    factor_defs = {fd.factor_id: fd for fd in g.db_session.query(FactorDefinition).all()}\n    \n    # Calculate scores for each category\n    category_scores = {}\n    category_counts = {}\n    total_score = 0\n    factor_count = 0\n    \n    for factor in factors:\n        if factor.likelihood is None or factor.impact is None:\n            continue\n        \n        score = factor.likelihood * factor.impact\n        category = factor.category\n        \n        if category not in category_scores:\n            category_scores[category] = 0\n            category_counts[category] = 0\n        \n        category_scores[category] += score\n        category_counts[category] += 1\n        total_score += score\n        factor_count += 1\n    \n    # Calculate average scores\n    for category in category_scores:\n        if category_counts[category] > 0:\n            category_scores[category] = round(category_scores[category] / category_counts[category])\n    \n    # Calculate overall score\n    overall_score = round(total_score / factor_count) if factor_count > 0 else 0\n    \n    # Determine risk level\n    if overall_score >= 20:\n        risk_level = RiskLevel.CRITICAL\n    elif overall_score >= 15:\n        risk_level = RiskLevel.HIGH\n    elif overall_score >= 8:\n        risk_level = RiskLevel.MEDIUM\n    else:\n        risk_level = RiskLevel.LOW\n    \n    # Get high risk factors\n    high_risk_factors = []\n    for factor in factors:\n        if factor.likelihood is None or factor.impact is None:\n            continue\n        \n        score = factor.likelihood * factor.impact\n        if score >= 15:\n            factor_name = factor_defs[factor.factor_id].name if factor.factor_id in factor_defs else factor.factor_id\n            high_risk_factors.append({\n                "id": factor.factor_id,\n                "name": factor_name,\n                "category": factor.category,\n                "score": score\n            })\n    \n    # Sort high risk factors by score (highest first)\n    high_risk_factors.sort(key=lambda x: x["score"], reverse=True)\n    \n    # Generate recommendations based on risk level\n    recommendations = []\n    if risk_level == RiskLevel.CRITICAL:\n        recommendations = [\n            "File a formal motion to recuse/disqualify immediately",\n            "Consider motion to stay proceedings pending resolution",\n            "Prepare detailed affidavit documenting all prejudice factors",\n            "Consult with appellate counsel regarding potential mandamus relief",\n            "Implement comprehensive documentation protocol for all interactions"\n        ]\n    elif risk_level == RiskLevel.HIGH:\n        recommendations = [\n            "File a motion to recuse/disqualify or for disclosure of potential conflicts",\n            "Consider requesting a hearing on prejudice concerns",\n            "Develop detailed documentation of all prejudice indicators",\n            "Implement strategic adjustments to case presentation",\n            "Prepare record for potential appeal on prejudice grounds"\n        ]\n    elif risk_level == RiskLevel.MEDIUM:\n        recommendations = [\n            "Enhance documentation of potential prejudice indicators",\n            "Consider strategic motion practice to test for bias",\n            "Modify case presentation approach to mitigate prejudice impact",\n            "Request written rulings for significant decisions",\n            "Preserve all procedural objections related to potential prejudice"\n        ]\n    else:  # Low\n        recommendations = [\n            "Document potential prejudice indicators as they arise",\n            "Track rulings for emerging patterns",\n            "Compare treatment with opposing party",\n            "Maintain professional conduct to avoid escalation",\n            "Reassess risk level periodically throughout proceedings"\n        ]\n    \n    return {\n        "overall_score": overall_score,\n        "risk_level": risk_level,\n        "category_scores": category_scores,\n        "high_risk_factors": high_risk_factors,\n        "recommendations": recommendations\n    }\n\n@results_bp.route(\'/assessments/<assessment_id>/calculate\', methods=[\'POST\'])\n@require_api_key\ndef calculate_results(assessment_id):\n    """Calculate risk scores based on current factor ratings"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Check if factors exist\n        factors = g.db_session.query(Factor).filter_by(assessment_id=assessment.id).all()\n        if not factors:\n            raise BadRequest("No factor ratings found for this assessment")\n        \n        # Calculate risk scores\n        timestamp = datetime.datetime.utcnow()\n        calculation = calculate_risk_score(assessment)\n        \n        # Create result record\n        result = Result(\n            assessment_id=assessment.id,\n            overall_score=calculation["overall_score"],\n            risk_level=calculation["risk_level"],\n            category_scores=json.dumps(calculation["category_scores"]),\n            high_risk_factors=json.dumps(calculation["high_risk_factors"]),\n            recommendations=json.dumps(calculation["recommendations"]),\n            calculated_at=timestamp\n        )\n        \n        # Check if risk level has changed\n        previous_result = assessment.latest_result\n        risk_level_changed = False\n        previous_level = None\n        previous_score = None\n        \n        if previous_result:\n            previous_level = previous_result.risk_level\n            previous_score = previous_result.overall_score\n            risk_level_changed = previous_result.risk_level != calculation["risk_level"]\n        \n        # Save result\n        g.db_session.add(result)\n        \n        # Update assessment status\n        assessment.status = "calculated"\n        assessment.updated_at = timestamp\n        \n        g.db_session.commit()\n        \n        # Prepare response\n        response_data = {\n            "assessment_id": assessment_id,\n            "overall_score": calculation["overall_score"],\n            "risk_level": calculation["risk_level"].value,\n            "category_scores": calculation["category_scores"],\n            "high_risk_factors": calculation["high_risk_factors"],\n            "recommendations": calculation["recommendations"],\n            "calculated_at": timestamp.isoformat()\n        }\n        \n        # Trigger result.calculated event\n        trigger_event(\'result.calculated\', response_data)\n        \n        # Trigger risk_level.changed event if applicable\n        if risk_level_changed:\n            # Find factors that changed significantly\n            changed_factors = []\n            if previous_result:\n                # This would require more complex logic to compare factors\n                # For now, we\'ll just note the overall change\n                changed_factors = [{\n                    "id": "overall",\n                    "previous_score": previous_score,\n                    "new_score": calculation["overall_score"]\n                }]\n            \n            trigger_event(\'risk_level.changed\', {\n                \'assessment_id\': assessment_id,\n                \'previous_level\': previous_level.value if previous_level else None,\n                \'new_level\': calculation["risk_level"].value,\n                \'previous_score\': previous_score,\n                \'new_score\': calculation["overall_score"],\n                \'changed_factors\': changed_factors,\n                \'changed_at\': timestamp.isoformat()\n            })\n        \n        return jsonify(response_data), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error calculating results: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error calculating results: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@results_bp.route(\'/assessments/<assessment_id>/results\', methods=[\'GET\'])\n@require_api_key\ndef get_results(assessment_id):\n    """Get all calculation results for an assessment"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Query results\n        results = g.db_session.query(Result).filter_by(assessment_id=assessment.id).order_by(Result.calculated_at.desc()).all()\n        \n        # Convert to dictionaries\n        result_list = [result.to_dict() for result in results]\n        \n        return jsonify({\n            "assessment_id": assessment_id,\n            "results": result_list\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving results: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@results_bp.route(\'/assessments/<assessment_id>/results/latest\', methods=[\'GET\'])\n@require_api_key\ndef get_latest_result(assessment_id):\n    """Get the latest calculation result for an assessment"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Get latest result\n        latest_result = assessment.latest_result\n        if not latest_result:\n            return jsonify({\n                "assessment_id": assessment_id,\n                "message": "No calculation results found for this assessment"\n            }), 404\n        \n        return jsonify(latest_result.to_dict()), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving latest result: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@results_bp.route(\'/assessments/<assessment_id>/export\', methods=[\'GET\'])\n@require_api_key\ndef export_results(assessment_id):\n    """Export assessment results in various formats"""\n    try:\n        # Get requested format\n        export_format = request.args.get(\'format\', \'json\').lower()\n        \n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Get latest result\n        latest_result = assessment.latest_result\n        if not latest_result:\n            return jsonify({\n                "error": "No calculation results found for this assessment"\n            }), 404\n        \n        # Get factors\n        factors = g.db_session.query(Factor).filter_by(assessment_id=assessment.id).all()\n        \n        # Get factor definitions for names\n        factor_defs = {fd.factor_id: fd for fd in g.db_session.query(FactorDefinition).all()}\n        \n        # Prepare export data\n        export_data = {\n            "assessment": assessment.to_dict(),\n            "result": latest_result.to_dict(),\n            "factors": [\n                {\n                    "id": factor.factor_id,\n                    "name": factor_defs[factor.factor_id].name if factor.factor_id in factor_defs else factor.factor_id,\n                    "category": factor.category,\n                    "likelihood": factor.likelihood,\n                    "impact": factor.impact,\n                    "score": factor.likelihood * factor.impact if factor.likelihood and factor.impact else None,\n                    "notes": factor.notes\n                }\n                for factor in factors\n            ],\n            "export_date": datetime.datetime.utcnow().isoformat()\n        }\n        \n        # Return based on requested format\n        if export_format == \'json\':\n            return jsonify(export_data), 200\n        elif export_format == \'pdf\':\n            # In a real implementation, this would generate a PDF\n            return jsonify({\n                "error": "PDF export not implemented in this version",\n                "message": "Please use JSON format for now"\n            }), 501\n        elif export_format == \'csv\':\n            # In a real implementation, this would generate CSV files\n            return jsonify({\n                "error": "CSV export not implemented in this version",\n                "message": "Please use JSON format for now"\n            }), 501\n        else:\n            return jsonify({\n                "error": "Unsupported export format",\n                "message": "Supported formats: json, pdf, csv"\n            }), 400\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error exporting results: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n</create-file>\n</function_calls>', 'tool_calls': None}