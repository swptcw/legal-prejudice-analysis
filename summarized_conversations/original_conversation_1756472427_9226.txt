{'role': 'assistant', 'content': 'Now, let\'s create a sample implementation of a basic API endpoint for our Legal Prejudice Risk Calculator. I\'ll use Python with Flask to create a simple API server:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/api_server.py">\n#!/usr/bin/env python3\n"""\nAPI Server for Legal Prejudice Risk Calculator\nThis provides a RESTful API for integrating the calculator with case management systems\n"""\n\nfrom flask import Flask, request, jsonify\nimport uuid\nimport datetime\nimport json\nimport os\nimport logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\')\nlogger = logging.getLogger(__name__)\n\n# Initialize Flask app\napp = Flask(__name__)\n\n# Data storage (in-memory for demo purposes)\n# In a production environment, this would be a database\nassessments = {}\nfactors_data = {}\n\n# Load factor definitions\nFACTOR_DEFINITIONS = {\n    "relationship": {\n        "name": "Relationship-Based",\n        "factors": [\n            {"id": "financial-direct", "name": "Direct financial interest"},\n            {"id": "financial-indirect", "name": "Indirect financial interest"},\n            {"id": "relationship-family", "name": "Family relationship"},\n            {"id": "relationship-social", "name": "Social/professional relationship"},\n            {"id": "political-contributions", "name": "Political contributions"},\n            {"id": "ideological-advocacy", "name": "Prior advocacy on disputed issue"}\n        ]\n    },\n    "conduct": {\n        "name": "Conduct-Based",\n        "factors": [\n            {"id": "statements-disparaging", "name": "Disparaging remarks"},\n            {"id": "statements-prejudgment", "name": "Expressions indicating prejudgment"},\n            {"id": "rulings-onesided", "name": "One-sided evidentiary rulings"},\n            {"id": "rulings-unequal", "name": "Unequal allocation of time/resources"},\n            {"id": "extrajudicial-public", "name": "Public comments on pending case"},\n            {"id": "extrajudicial-media", "name": "Media interviews/social media posts"}\n        ]\n    },\n    "contextual": {\n        "name": "Contextual",\n        "factors": [\n            {"id": "historical-consistent", "name": "Consistent rulings favoring similar parties"},\n            {"id": "historical-prior", "name": "Prior reversal for bias"},\n            {"id": "procedural-deviation", "name": "Deviation from standard procedures"},\n            {"id": "procedural-reasoning", "name": "Failure to provide reasoning"},\n            {"id": "external-public", "name": "High-profile case with public pressure"},\n            {"id": "external-political", "name": "Political implications for judge"}\n        ]\n    }\n}\n\n# Helper functions\ndef generate_assessment_id():\n    """Generate a unique assessment ID"""\n    year = datetime.datetime.now().year\n    count = len(assessments) + 1\n    return f"PRF-{year}-{count:04d}"\n\ndef generate_token():\n    """Generate a simple access token"""\n    # In a real implementation, this would be a proper JWT\n    return str(uuid.uuid4())\n\ndef get_timestamp():\n    """Get current timestamp in ISO format"""\n    return datetime.datetime.utcnow().isoformat() + "Z"\n\ndef calculate_risk_score(factor_ratings):\n    """Calculate risk scores based on factor ratings"""\n    category_scores = {}\n    total_score = 0\n    factor_count = 0\n    \n    # Calculate scores for each category\n    for category, category_data in FACTOR_DEFINITIONS.items():\n        category_total = 0\n        category_count = 0\n        \n        for factor in category_data["factors"]:\n            factor_id = factor["id"]\n            if factor_id in factor_ratings and "likelihood" in factor_ratings[factor_id] and "impact" in factor_ratings[factor_id]:\n                likelihood = factor_ratings[factor_id]["likelihood"]\n                impact = factor_ratings[factor_id]["impact"]\n                score = likelihood * impact\n                \n                category_total += score\n                category_count += 1\n                \n                total_score += score\n                factor_count += 1\n        \n        if category_count > 0:\n            category_scores[category] = round(category_total / category_count)\n    \n    # Calculate overall score\n    overall_score = round(total_score / factor_count) if factor_count > 0 else 0\n    \n    # Determine risk level\n    if overall_score >= 20:\n        risk_level = "Critical"\n    elif overall_score >= 15:\n        risk_level = "High"\n    elif overall_score >= 8:\n        risk_level = "Medium"\n    else:\n        risk_level = "Low"\n    \n    # Get high risk factors\n    high_risk_factors = []\n    for category, category_data in FACTOR_DEFINITIONS.items():\n        for factor in category_data["factors"]:\n            factor_id = factor["id"]\n            if factor_id in factor_ratings and "likelihood" in factor_ratings[factor_id] and "impact" in factor_ratings[factor_id]:\n                likelihood = factor_ratings[factor_id]["likelihood"]\n                impact = factor_ratings[factor_id]["impact"]\n                score = likelihood * impact\n                \n                if score >= 15:\n                    high_risk_factors.append({\n                        "id": factor_id,\n                        "name": factor["name"],\n                        "category": category_data["name"],\n                        "score": score\n                    })\n    \n    # Sort high risk factors by score (highest first)\n    high_risk_factors.sort(key=lambda x: x["score"], reverse=True)\n    \n    # Generate recommendations based on risk level\n    recommendations = []\n    if risk_level == "Critical":\n        recommendations = [\n            "File a formal motion to recuse/disqualify immediately",\n            "Consider motion to stay proceedings pending resolution",\n            "Prepare detailed affidavit documenting all prejudice factors",\n            "Consult with appellate counsel regarding potential mandamus relief",\n            "Implement comprehensive documentation protocol for all interactions"\n        ]\n    elif risk_level == "High":\n        recommendations = [\n            "File a motion to recuse/disqualify or for disclosure of potential conflicts",\n            "Consider requesting a hearing on prejudice concerns",\n            "Develop detailed documentation of all prejudice indicators",\n            "Implement strategic adjustments to case presentation",\n            "Prepare record for potential appeal on prejudice grounds"\n        ]\n    elif risk_level == "Medium":\n        recommendations = [\n            "Enhance documentation of potential prejudice indicators",\n            "Consider strategic motion practice to test for bias",\n            "Modify case presentation approach to mitigate prejudice impact",\n            "Request written rulings for significant decisions",\n            "Preserve all procedural objections related to potential prejudice"\n        ]\n    else:  # Low\n        recommendations = [\n            "Document potential prejudice indicators as they arise",\n            "Track rulings for emerging patterns",\n            "Compare treatment with opposing party",\n            "Maintain professional conduct to avoid escalation",\n            "Reassess risk level periodically throughout proceedings"\n        ]\n    \n    return {\n        "overall_score": overall_score,\n        "risk_level": risk_level,\n        "category_scores": category_scores,\n        "high_risk_factors": high_risk_factors,\n        "recommendations": recommendations,\n        "calculated_at": get_timestamp()\n    }\n\n# API Authentication middleware\ndef authenticate_request():\n    """Simple API key authentication"""\n    api_key = request.headers.get(\'Authorization\')\n    if not api_key or not api_key.startswith(\'ApiKey \'):\n        return False\n    \n    # In a real implementation, this would validate against stored API keys\n    # For demo purposes, accept any key that starts with "TEST_"\n    key = api_key.replace(\'ApiKey \', \'\')\n    return key.startswith(\'TEST_\')\n\n# API Routes\n@app.route(\'/api/v1/assessments\', methods=[\'POST\'])\ndef create_assessment():\n    """Create a new prejudice risk assessment"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        data = request.json\n        \n        # Validate required fields\n        required_fields = ["case_name", "judge_name", "assessor_name"]\n        for field in required_fields:\n            if field not in data:\n                return jsonify({"error": f"Missing required field: {field}"}), 400\n        \n        # Generate assessment ID and token\n        assessment_id = generate_assessment_id()\n        access_token = generate_token()\n        timestamp = get_timestamp()\n        \n        # Create assessment record\n        assessment = {\n            "assessment_id": assessment_id,\n            "case_name": data["case_name"],\n            "judge_name": data["judge_name"],\n            "assessor_name": data["assessor_name"],\n            "assessment_date": data.get("assessment_date", timestamp.split("T")[0]),\n            "case_id": data.get("case_id", ""),\n            "case_management_system_id": data.get("case_management_system_id", ""),\n            "status": "created",\n            "created_at": timestamp,\n            "updated_at": timestamp,\n            "access_token": access_token\n        }\n        \n        # Store assessment\n        assessments[assessment_id] = assessment\n        factors_data[assessment_id] = {}\n        \n        # Log creation\n        logger.info(f"Assessment created: {assessment_id}")\n        \n        # Return response\n        return jsonify({\n            "assessment_id": assessment_id,\n            "status": "created",\n            "created_at": timestamp,\n            "access_token": access_token\n        }), 201\n        \n    except Exception as e:\n        logger.error(f"Error creating assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>\', methods=[\'GET\'])\ndef get_assessment(assessment_id):\n    """Retrieve an existing assessment"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        # Get assessment data\n        assessment = assessments[assessment_id].copy()\n        \n        # Remove access token from response\n        if "access_token" in assessment:\n            del assessment["access_token"]\n        \n        # Add factors if available\n        if assessment_id in factors_data:\n            factor_list = []\n            for factor_id, factor_data in factors_data[assessment_id].items():\n                # Find factor name and category\n                factor_name = ""\n                factor_category = ""\n                for category, category_data in FACTOR_DEFINITIONS.items():\n                    for factor in category_data["factors"]:\n                        if factor["id"] == factor_id:\n                            factor_name = factor["name"]\n                            factor_category = category_data["name"]\n                            break\n                \n                # Calculate score if likelihood and impact are available\n                score = 0\n                if "likelihood" in factor_data and "impact" in factor_data:\n                    score = factor_data["likelihood"] * factor_data["impact"]\n                \n                factor_list.append({\n                    "id": factor_id,\n                    "name": factor_name,\n                    "category": factor_category,\n                    "likelihood": factor_data.get("likelihood", 0),\n                    "impact": factor_data.get("impact", 0),\n                    "score": score,\n                    "notes": factor_data.get("notes", "")\n                })\n            \n            assessment["factors"] = factor_list\n        \n        # Log retrieval\n        logger.info(f"Assessment retrieved: {assessment_id}")\n        \n        return jsonify(assessment), 200\n        \n    except Exception as e:\n        logger.error(f"Error retrieving assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>\', methods=[\'PUT\'])\ndef update_assessment(assessment_id):\n    """Update an existing assessment"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        data = request.json\n        timestamp = get_timestamp()\n        \n        # Update assessment fields\n        for field in ["case_name", "judge_name", "assessor_name", "assessment_date", "case_id", "case_management_system_id"]:\n            if field in data:\n                assessments[assessment_id][field] = data[field]\n        \n        # Update timestamp\n        assessments[assessment_id]["updated_at"] = timestamp\n        assessments[assessment_id]["status"] = "updated"\n        \n        # Log update\n        logger.info(f"Assessment updated: {assessment_id}")\n        \n        return jsonify({\n            "assessment_id": assessment_id,\n            "status": "updated",\n            "updated_at": timestamp\n        }), 200\n        \n    except Exception as e:\n        logger.error(f"Error updating assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>\', methods=[\'DELETE\'])\ndef delete_assessment(assessment_id):\n    """Delete an assessment"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        timestamp = get_timestamp()\n        \n        # Delete assessment and factors\n        del assessments[assessment_id]\n        if assessment_id in factors_data:\n            del factors_data[assessment_id]\n        \n        # Log deletion\n        logger.info(f"Assessment deleted: {assessment_id}")\n        \n        return jsonify({\n            "status": "deleted",\n            "deleted_at": timestamp\n        }), 200\n        \n    except Exception as e:\n        logger.error(f"Error deleting assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>/factors\', methods=[\'POST\'])\ndef submit_factor_ratings(assessment_id):\n    """Submit ratings for multiple factors"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        data = request.json\n        timestamp = get_timestamp()\n        \n        # Validate request\n        if "factors" not in data or not isinstance(data["factors"], list):\n            return jsonify({"error": "Invalid request format"}), 400\n        \n        # Initialize factors data if not exists\n        if assessment_id not in factors_data:\n            factors_data[assessment_id] = {}\n        \n        # Process factors\n        factors_updated = 0\n        for factor in data["factors"]:\n            # Validate factor data\n            if "id" not in factor:\n                continue\n            \n            factor_id = factor["id"]\n            \n            # Check if factor exists in definitions\n            factor_exists = False\n            for category, category_data in FACTOR_DEFINITIONS.items():\n                for def_factor in category_data["factors"]:\n                    if def_factor["id"] == factor_id:\n                        factor_exists = True\n                        break\n                if factor_exists:\n                    break\n            \n            if not factor_exists:\n                continue\n            \n            # Initialize factor data if not exists\n            if factor_id not in factors_data[assessment_id]:\n                factors_data[assessment_id][factor_id] = {}\n            \n            # Update factor data\n            for field in ["likelihood", "impact", "notes"]:\n                if field in factor:\n                    factors_data[assessment_id][factor_id][field] = factor[field]\n            \n            factors_updated += 1\n        \n        # Update assessment status\n        assessments[assessment_id]["status"] = "in_progress"\n        assessments[assessment_id]["updated_at"] = timestamp\n        \n        # Log update\n        logger.info(f"Factor ratings submitted for assessment {assessment_id}: {factors_updated} factors updated")\n        \n        return jsonify({\n            "status": "success",\n            "factors_updated": factors_updated,\n            "updated_at": timestamp\n        }), 200\n        \n    except Exception as e:\n        logger.error(f"Error submitting factor ratings: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>/factors\', methods=[\'GET\'])\ndef get_factor_ratings(assessment_id):\n    """Retrieve all factor ratings for an assessment"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        # Check if factors exist\n        if assessment_id not in factors_data:\n            return jsonify({\n                "assessment_id": assessment_id,\n                "factors": []\n            }), 200\n        \n        # Prepare factor list\n        factor_list = []\n        for factor_id, factor_data in factors_data[assessment_id].items():\n            # Find factor name and category\n            factor_name = ""\n            factor_category = ""\n            category_name = ""\n            for category, category_data in FACTOR_DEFINITIONS.items():\n                for factor in category_data["factors"]:\n                    if factor["id"] == factor_id:\n                        factor_name = factor["name"]\n                        factor_category = category\n                        category_name = category_data["name"]\n                        break\n            \n            # Calculate score if likelihood and impact are available\n            score = 0\n            if "likelihood" in factor_data and "impact" in factor_data:\n                score = factor_data["likelihood"] * factor_data["impact"]\n            \n            factor_list.append({\n                "id": factor_id,\n                "name": factor_name,\n                "category": category_name,\n                "category_id": factor_category,\n                "likelihood": factor_data.get("likelihood", 0),\n                "impact": factor_data.get("impact", 0),\n                "score": score,\n                "notes": factor_data.get("notes", "")\n            })\n        \n        # Log retrieval\n        logger.info(f"Factor ratings retrieved for assessment {assessment_id}")\n        \n        return jsonify({\n            "assessment_id": assessment_id,\n            "factors": factor_list\n        }), 200\n        \n    except Exception as e:\n        logger.error(f"Error retrieving factor ratings: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>/calculate\', methods=[\'POST\'])\ndef calculate_results(assessment_id):\n    """Calculate risk scores based on current factor ratings"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        # Check if factors exist\n        if assessment_id not in factors_data or not factors_data[assessment_id]:\n            return jsonify({"error": "No factor ratings found"}), 400\n        \n        # Calculate risk scores\n        results = calculate_risk_score(factors_data[assessment_id])\n        \n        # Update assessment status\n        timestamp = get_timestamp()\n        assessments[assessment_id]["status"] = "calculated"\n        assessments[assessment_id]["updated_at"] = timestamp\n        \n        # Store results\n        assessments[assessment_id]["results"] = results\n        \n        # Add assessment ID to results\n        results["assessment_id"] = assessment_id\n        \n        # Log calculation\n        logger.info(f"Results calculated for assessment {assessment_id}: Risk level {results[\'risk_level\']}")\n        \n        return jsonify(results), 200\n        \n    except Exception as e:\n        logger.error(f"Error calculating results: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/assessments/<assessment_id>/link\', methods=[\'POST\'])\ndef link_to_case(assessment_id):\n    """Link assessment to a case in external case management system"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        # Check if assessment exists\n        if assessment_id not in assessments:\n            return jsonify({"error": "Assessment not found"}), 404\n        \n        data = request.json\n        timestamp = get_timestamp()\n        \n        # Validate required fields\n        required_fields = ["cms_type", "case_id"]\n        for field in required_fields:\n            if field not in data:\n                return jsonify({"error": f"Missing required field: {field}"}), 400\n        \n        # Update assessment with CMS information\n        assessments[assessment_id]["cms_type"] = data["cms_type"]\n        assessments[assessment_id]["cms_case_id"] = data["case_id"]\n        assessments[assessment_id]["cms_matter_id"] = data.get("matter_id", "")\n        assessments[assessment_id]["cms_sync_data"] = data.get("sync_data", False)\n        assessments[assessment_id]["cms_linked_at"] = timestamp\n        assessments[assessment_id]["updated_at"] = timestamp\n        \n        # Log linking\n        logger.info(f"Assessment {assessment_id} linked to {data[\'cms_type\']} case {data[\'case_id\']}")\n        \n        return jsonify({\n            "status": "linked",\n            "cms_type": data["cms_type"],\n            "case_id": data["case_id"],\n            "linked_at": timestamp\n        }), 200\n        \n    except Exception as e:\n        logger.error(f"Error linking assessment to case: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/factor_definitions\', methods=[\'GET\'])\ndef get_factor_definitions():\n    """Get all factor definitions"""\n    if not authenticate_request():\n        return jsonify({"error": "Unauthorized"}), 401\n    \n    try:\n        return jsonify(FACTOR_DEFINITIONS), 200\n        \n    except Exception as e:\n        logger.error(f"Error retrieving factor definitions: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@app.route(\'/api/v1/status\', methods=[\'GET\'])\ndef get_api_status():\n    """Get API status"""\n    return jsonify({\n        "status": "operational",\n        "version": "1.0.0",\n        "timestamp": get_timestamp(),\n        "assessments_count": len(assessments)\n    }), 200\n\n# Main entry point\nif __name__ == \'__main__\':\n    # Create data directory if it doesn\'t exist\n    data_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), \'data\')\n    os.makedirs(data_dir, exist_ok=True)\n    \n    # Start the server\n    app.run(host=\'0.0.0.0\', port=5000, debug=True)\n</create-file>\n</function_calls>', 'tool_calls': None}