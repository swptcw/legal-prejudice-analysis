{'role': 'assistant', 'content': 'Now, let\'s create the factors routes file:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/routes/factors.py">\n"""\nRoutes for factor management\n"""\n\nimport datetime\nfrom flask import Blueprint, jsonify, request, current_app, g\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom werkzeug.exceptions import NotFound, BadRequest\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom models import Assessment, Factor, FactorDefinition\nfrom utils.auth import require_api_key\nfrom utils.validation import validate_factor_data\nfrom utils.events import trigger_event\n\n# Create blueprint\nfactors_bp = Blueprint(\'factors\', __name__)\n\n# Initialize rate limiter\nlimiter = Limiter(key_func=get_remote_address)\n\n@factors_bp.route(\'/definitions\', methods=[\'GET\'])\n@require_api_key\ndef get_factor_definitions():\n    """Get all factor definitions"""\n    try:\n        # Query factor definitions\n        definitions = g.db_session.query(FactorDefinition).all()\n        \n        # Organize by category\n        categories = {}\n        for definition in definitions:\n            if definition.category not in categories:\n                categories[definition.category] = {\n                    "name": definition.category,\n                    "factors": []\n                }\n            \n            categories[definition.category]["factors"].append(definition.to_dict())\n        \n        return jsonify(categories), 200\n        \n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving factor definitions: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@factors_bp.route(\'/assessments/<assessment_id>/factors\', methods=[\'POST\'])\n@require_api_key\ndef submit_factor_ratings(assessment_id):\n    """Submit ratings for multiple factors"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Validate request data\n        data = request.get_json()\n        if not data or "factors" not in data or not isinstance(data["factors"], list):\n            raise BadRequest("Invalid request format. Expected \'factors\' array")\n        \n        # Process factors\n        timestamp = datetime.datetime.utcnow()\n        factors_updated = 0\n        updated_factors = []\n        \n        for factor_data in data["factors"]:\n            # Validate factor data\n            errors = validate_factor_data(factor_data)\n            if errors:\n                continue\n            \n            factor_id = factor_data["id"]\n            \n            # Check if factor definition exists\n            factor_def = g.db_session.query(FactorDefinition).filter_by(factor_id=factor_id).first()\n            if not factor_def:\n                continue\n            \n            # Check if factor already exists for this assessment\n            factor = g.db_session.query(Factor).filter_by(\n                assessment_id=assessment.id,\n                factor_id=factor_id\n            ).first()\n            \n            if not factor:\n                # Create new factor\n                factor = Factor(\n                    assessment_id=assessment.id,\n                    factor_id=factor_id,\n                    category=factor_def.category,\n                    created_at=timestamp,\n                    updated_at=timestamp\n                )\n                g.db_session.add(factor)\n            \n            # Update factor data\n            if "likelihood" in factor_data:\n                factor.likelihood = factor_data["likelihood"]\n            \n            if "impact" in factor_data:\n                factor.impact = factor_data["impact"]\n            \n            if "notes" in factor_data:\n                factor.notes = factor_data["notes"]\n            \n            factor.updated_at = timestamp\n            factors_updated += 1\n            \n            # Add to updated factors list for event\n            updated_factors.append({\n                "id": factor_id,\n                "name": factor_def.name,\n                "category": factor_def.category,\n                "likelihood": factor.likelihood,\n                "impact": factor.impact,\n                "score": factor.likelihood * factor.impact if factor.likelihood and factor.impact else None\n            })\n        \n        # Update assessment status\n        if factors_updated > 0:\n            assessment.status = "in_progress"\n            assessment.updated_at = timestamp\n        \n        # Save changes\n        g.db_session.commit()\n        \n        # Trigger event\n        if factors_updated > 0:\n            trigger_event(\'factor.updated\', {\n                \'assessment_id\': assessment_id,\n                \'factors_updated\': updated_factors,\n                \'updated_at\': timestamp.isoformat()\n            })\n        \n        return jsonify({\n            "status": "success",\n            "factors_updated": factors_updated,\n            "updated_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error submitting factor ratings: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error submitting factor ratings: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@factors_bp.route(\'/assessments/<assessment_id>/factors\', methods=[\'GET\'])\n@require_api_key\ndef get_factor_ratings(assessment_id):\n    """Retrieve all factor ratings for an assessment"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Query factors\n        factors = g.db_session.query(Factor).filter_by(assessment_id=assessment.id).all()\n        \n        # Get factor definitions for names\n        factor_defs = {fd.factor_id: fd for fd in g.db_session.query(FactorDefinition).all()}\n        \n        # Prepare factor list\n        factor_list = []\n        for factor in factors:\n            factor_dict = factor.to_dict()\n            \n            # Add factor name from definition\n            if factor.factor_id in factor_defs:\n                factor_dict["name"] = factor_defs[factor.factor_id].name\n            else:\n                factor_dict["name"] = factor.factor_id\n            \n            factor_list.append(factor_dict)\n        \n        return jsonify({\n            "assessment_id": assessment_id,\n            "factors": factor_list\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving factor ratings: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@factors_bp.route(\'/assessments/<assessment_id>/factors/<factor_id>\', methods=[\'PUT\'])\n@require_api_key\ndef update_factor(assessment_id, factor_id):\n    """Update a specific factor"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Check if factor definition exists\n        factor_def = g.db_session.query(FactorDefinition).filter_by(factor_id=factor_id).first()\n        if not factor_def:\n            raise NotFound(f"Factor definition {factor_id} not found")\n        \n        # Get request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        # Validate factor data\n        errors = validate_factor_data(data, require_id=False)\n        if errors:\n            return jsonify({"errors": errors}), 400\n        \n        # Query factor\n        factor = g.db_session.query(Factor).filter_by(\n            assessment_id=assessment.id,\n            factor_id=factor_id\n        ).first()\n        \n        timestamp = datetime.datetime.utcnow()\n        \n        if not factor:\n            # Create new factor\n            factor = Factor(\n                assessment_id=assessment.id,\n                factor_id=factor_id,\n                category=factor_def.category,\n                created_at=timestamp,\n                updated_at=timestamp\n            )\n            g.db_session.add(factor)\n        \n        # Update factor data\n        if "likelihood" in data:\n            factor.likelihood = data["likelihood"]\n        \n        if "impact" in data:\n            factor.impact = data["impact"]\n        \n        if "notes" in data:\n            factor.notes = data["notes"]\n        \n        factor.updated_at = timestamp\n        \n        # Update assessment status\n        assessment.status = "in_progress"\n        assessment.updated_at = timestamp\n        \n        # Save changes\n        g.db_session.commit()\n        \n        # Trigger event\n        trigger_event(\'factor.updated\', {\n            \'assessment_id\': assessment_id,\n            \'factors_updated\': [{\n                "id": factor_id,\n                "name": factor_def.name,\n                "category": factor_def.category,\n                "likelihood": factor.likelihood,\n                "impact": factor.impact,\n                "score": factor.likelihood * factor.impact if factor.likelihood and factor.impact else None\n            }],\n            \'updated_at\': timestamp.isoformat()\n        })\n        \n        return jsonify({\n            "status": "updated",\n            "factor_id": factor_id,\n            "updated_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error updating factor: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error updating factor: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n</create-file>\n</function_calls>', 'tool_calls': None}