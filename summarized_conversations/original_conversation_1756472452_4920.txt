{'role': 'assistant', 'content': 'Now, let\'s create the authentication routes:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/routes/auth.py">\n"""\nRoutes for authentication and API key management\n"""\n\nimport datetime\nimport uuid\nimport secrets\nimport hashlib\nfrom flask import Blueprint, jsonify, request, current_app, g\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom werkzeug.exceptions import NotFound, BadRequest, Unauthorized\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom models import APIKey\nfrom utils.auth import require_api_key, is_admin\n\n# Create blueprint\nauth_bp = Blueprint(\'auth\', __name__)\n\n# Initialize rate limiter\nlimiter = Limiter(key_func=get_remote_address)\n\ndef generate_api_key():\n    """Generate a secure API key"""\n    # Format: prfk_<random string>\n    return f"prfk_{secrets.token_urlsafe(32)}"\n\ndef hash_api_key(api_key):\n    """Hash an API key for storage"""\n    return hashlib.sha256(api_key.encode(\'utf-8\')).hexdigest()\n\n@auth_bp.route(\'/keys\', methods=[\'POST\'])\n@require_api_key\n@is_admin\n@limiter.limit("10 per hour")\ndef create_api_key():\n    """Create a new API key"""\n    try:\n        # Validate request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        required_fields = ["name", "created_by"]\n        for field in required_fields:\n            if field not in data:\n                raise BadRequest(f"Missing required field: {field}")\n        \n        # Generate API key\n        api_key = generate_api_key()\n        key_hash = hash_api_key(api_key)\n        timestamp = datetime.datetime.utcnow()\n        \n        # Set expiration if provided\n        expires_at = None\n        if "expires_in_days" in data:\n            try:\n                days = int(data["expires_in_days"])\n                if days > 0:\n                    expires_at = timestamp + datetime.timedelta(days=days)\n            except (ValueError, TypeError):\n                pass\n        \n        # Create API key record\n        key = APIKey(\n            key_id=str(uuid.uuid4()),\n            key_hash=key_hash,\n            name=data["name"],\n            description=data.get("description", ""),\n            created_by=data["created_by"],\n            is_active=True,\n            expires_at=expires_at,\n            created_at=timestamp,\n            updated_at=timestamp\n        )\n        \n        # Save to database\n        g.db_session.add(key)\n        g.db_session.commit()\n        \n        # Return response with the actual API key\n        # This is the only time the actual key will be returned\n        return jsonify({\n            "key_id": key.key_id,\n            "api_key": api_key,  # Only returned once\n            "name": key.name,\n            "description": key.description,\n            "created_by": key.created_by,\n            "is_active": key.is_active,\n            "expires_at": key.expires_at.isoformat() if key.expires_at else None,\n            "created_at": key.created_at.isoformat()\n        }), 201\n        \n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error creating API key: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error creating API key: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/keys\', methods=[\'GET\'])\n@require_api_key\n@is_admin\ndef list_api_keys():\n    """List all API keys"""\n    try:\n        # Query API keys\n        keys = g.db_session.query(APIKey).all()\n        \n        # Convert to dictionaries (without key hash)\n        key_list = []\n        for key in keys:\n            key_dict = {\n                "key_id": key.key_id,\n                "name": key.name,\n                "description": key.description,\n                "created_by": key.created_by,\n                "is_active": key.is_active,\n                "last_used_at": key.last_used_at.isoformat() if key.last_used_at else None,\n                "expires_at": key.expires_at.isoformat() if key.expires_at else None,\n                "created_at": key.created_at.isoformat()\n            }\n            key_list.append(key_dict)\n        \n        return jsonify({\n            "api_keys": key_list\n        }), 200\n        \n    except Exception as e:\n        current_app.logger.exception(f"Error listing API keys: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/keys/<key_id>\', methods=[\'GET\'])\n@require_api_key\n@is_admin\ndef get_api_key(key_id):\n    """Get a specific API key"""\n    try:\n        # Query API key\n        key = g.db_session.query(APIKey).filter_by(key_id=key_id).first()\n        if not key:\n            raise NotFound(f"API key {key_id} not found")\n        \n        # Convert to dictionary (without key hash)\n        key_dict = {\n            "key_id": key.key_id,\n            "name": key.name,\n            "description": key.description,\n            "created_by": key.created_by,\n            "is_active": key.is_active,\n            "last_used_at": key.last_used_at.isoformat() if key.last_used_at else None,\n            "expires_at": key.expires_at.isoformat() if key.expires_at else None,\n            "created_at": key.created_at.isoformat(),\n            "updated_at": key.updated_at.isoformat()\n        }\n        \n        return jsonify(key_dict), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving API key: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/keys/<key_id>\', methods=[\'PUT\'])\n@require_api_key\n@is_admin\ndef update_api_key(key_id):\n    """Update an API key"""\n    try:\n        # Query API key\n        key = g.db_session.query(APIKey).filter_by(key_id=key_id).first()\n        if not key:\n            raise NotFound(f"API key {key_id} not found")\n        \n        # Get request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        # Update API key fields\n        timestamp = datetime.datetime.utcnow()\n        updated = False\n        \n        if "name" in data:\n            key.name = data["name"]\n            updated = True\n        \n        if "description" in data:\n            key.description = data["description"]\n            updated = True\n        \n        if "is_active" in data:\n            key.is_active = bool(data["is_active"])\n            updated = True\n        \n        if "expires_at" in data:\n            if data["expires_at"] is None:\n                key.expires_at = None\n                updated = True\n            else:\n                try:\n                    key.expires_at = datetime.datetime.fromisoformat(data["expires_at"])\n                    updated = True\n                except ValueError:\n                    raise BadRequest("Invalid expires_at format. Use ISO 8601 format")\n        \n        if updated:\n            key.updated_at = timestamp\n            g.db_session.commit()\n        \n        # Convert to dictionary (without key hash)\n        key_dict = {\n            "key_id": key.key_id,\n            "name": key.name,\n            "description": key.description,\n            "created_by": key.created_by,\n            "is_active": key.is_active,\n            "last_used_at": key.last_used_at.isoformat() if key.last_used_at else None,\n            "expires_at": key.expires_at.isoformat() if key.expires_at else None,\n            "created_at": key.created_at.isoformat(),\n            "updated_at": key.updated_at.isoformat()\n        }\n        \n        return jsonify(key_dict), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error updating API key: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error updating API key: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/keys/<key_id>\', methods=[\'DELETE\'])\n@require_api_key\n@is_admin\ndef delete_api_key(key_id):\n    """Delete an API key"""\n    try:\n        # Query API key\n        key = g.db_session.query(APIKey).filter_by(key_id=key_id).first()\n        if not key:\n            raise NotFound(f"API key {key_id} not found")\n        \n        # Delete API key\n        timestamp = datetime.datetime.utcnow()\n        g.db_session.delete(key)\n        g.db_session.commit()\n        \n        return jsonify({\n            "key_id": key_id,\n            "deleted": True,\n            "deleted_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error deleting API key: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error deleting API key: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/keys/<key_id>/revoke\', methods=[\'POST\'])\n@require_api_key\n@is_admin\ndef revoke_api_key(key_id):\n    """Revoke an API key"""\n    try:\n        # Query API key\n        key = g.db_session.query(APIKey).filter_by(key_id=key_id).first()\n        if not key:\n            raise NotFound(f"API key {key_id} not found")\n        \n        # Revoke API key\n        timestamp = datetime.datetime.utcnow()\n        key.is_active = False\n        key.updated_at = timestamp\n        g.db_session.commit()\n        \n        return jsonify({\n            "key_id": key_id,\n            "is_active": False,\n            "revoked_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error revoking API key: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error revoking API key: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/keys/<key_id>/rotate\', methods=[\'POST\'])\n@require_api_key\n@is_admin\n@limiter.limit("10 per hour")\ndef rotate_api_key(key_id):\n    """Rotate an API key (generate a new key while preserving metadata)"""\n    try:\n        # Query API key\n        key = g.db_session.query(APIKey).filter_by(key_id=key_id).first()\n        if not key:\n            raise NotFound(f"API key {key_id} not found")\n        \n        # Generate new API key\n        api_key = generate_api_key()\n        key_hash = hash_api_key(api_key)\n        timestamp = datetime.datetime.utcnow()\n        \n        # Update API key\n        key.key_hash = key_hash\n        key.updated_at = timestamp\n        g.db_session.commit()\n        \n        # Return response with the new API key\n        return jsonify({\n            "key_id": key.key_id,\n            "api_key": api_key,  # Only returned once\n            "name": key.name,\n            "description": key.description,\n            "created_by": key.created_by,\n            "is_active": key.is_active,\n            "expires_at": key.expires_at.isoformat() if key.expires_at else None,\n            "rotated_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error rotating API key: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error rotating API key: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@auth_bp.route(\'/validate\', methods=[\'POST\'])\n@limiter.limit("60 per minute")\ndef validate_api_key():\n    """Validate an API key"""\n    try:\n        # Get API key from request\n        auth_header = request.headers.get(\'Authorization\')\n        if not auth_header or not auth_header.startswith(\'ApiKey \'):\n            raise Unauthorized("Missing or invalid Authorization header")\n        \n        api_key = auth_header.replace(\'ApiKey \', \'\')\n        key_hash = hash_api_key(api_key)\n        \n        # Query API key\n        key = g.db_session.query(APIKey).filter_by(key_hash=key_hash).first()\n        if not key:\n            raise Unauthorized("Invalid API key")\n        \n        # Check if key is active\n        if not key.is_active:\n            raise Unauthorized("API key is inactive")\n        \n        # Check if key is expired\n        if key.expires_at and key.expires_at < datetime.datetime.utcnow():\n            raise Unauthorized("API key is expired")\n        \n        # Update last used timestamp\n        timestamp = datetime.datetime.utcnow()\n        key.last_used_at = timestamp\n        g.db_session.commit()\n        \n        return jsonify({\n            "valid": True,\n            "key_id": key.key_id,\n            "name": key.name,\n            "expires_at": key.expires_at.isoformat() if key.expires_at else None,\n            "validated_at": timestamp.isoformat()\n        }), 200\n        \n    except Unauthorized as e:\n        return jsonify({\n            "valid": False,\n            "error": str(e)\n        }), 401\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error validating API key: {str(e)}")\n        return jsonify({\n            "valid": False,\n            "error": "Database error"\n        }), 500\n    except Exception as e:\n        current_app.logger.exception(f"Error validating API key: {str(e)}")\n        return jsonify({\n            "valid": False,\n            "error": "Internal server error"\n        }), 500\n</create-file>\n</function_calls>', 'tool_calls': None}