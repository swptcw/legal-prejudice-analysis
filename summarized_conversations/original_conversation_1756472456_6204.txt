{'role': 'assistant', 'content': 'Let\'s create the events utility:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/utils/events.py">\n"""\nEvent handling utilities for webhooks and notifications\n"""\n\nimport json\nimport uuid\nimport datetime\nimport hmac\nimport hashlib\nimport threading\nimport requests\nimport time\nfrom flask import current_app, g\n\nfrom models import Webhook, WebhookDelivery\n\n# In-memory event handlers (in a real implementation, this would be more robust)\nwebhook_handlers = {}\n\ndef register_webhook_handler(webhook):\n    """Register a webhook handler"""\n    webhook_id = webhook.webhook_id\n    events = json.loads(webhook.events) if isinstance(webhook.events, str) else webhook.events\n    \n    # Store webhook handler\n    webhook_handlers[webhook_id] = {\n        "id": webhook.id,\n        "webhook_id": webhook_id,\n        "target_url": webhook.target_url,\n        "events": events,\n        "secret_hash": webhook.secret_hash,\n        "active": webhook.active,\n        "content_type": webhook.content_type\n    }\n    \n    current_app.logger.info(f"Registered webhook handler {webhook_id} for events: {\', \'.join(events)}")\n\ndef load_webhook_handlers():\n    """Load all webhook handlers from database"""\n    try:\n        webhooks = g.db_session.query(Webhook).filter_by(active=True).all()\n        for webhook in webhooks:\n            register_webhook_handler(webhook)\n        \n        current_app.logger.info(f"Loaded {len(webhooks)} webhook handlers")\n    except Exception as e:\n        current_app.logger.exception(f"Error loading webhook handlers: {str(e)}")\n\ndef trigger_event(event_type, data):\n    """Trigger an event and notify all registered handlers"""\n    # Check if webhooks are enabled\n    if not current_app.config.get(\'ENABLE_WEBHOOKS\', True):\n        current_app.logger.info(f"Webhooks disabled, not triggering event {event_type}")\n        return\n    \n    # Create event\n    event_id = f"evt_{str(uuid.uuid4())[:8]}"\n    timestamp = datetime.datetime.utcnow()\n    \n    event_data = {\n        "id": event_id,\n        "event": event_type,\n        "created_at": timestamp.isoformat(),\n        "api_version": current_app.config.get(\'API_VERSION\', \'v1\'),\n        "data": data\n    }\n    \n    current_app.logger.info(f"Triggered event {event_type} with ID {event_id}")\n    \n    # Notify handlers\n    for webhook_id, handler in webhook_handlers.items():\n        if handler["active"] and event_type in handler["events"]:\n            # In a production environment, this would be handled by a queue system\n            # For now, we\'ll use a thread to avoid blocking the request\n            thread = threading.Thread(\n                target=deliver_webhook,\n                args=(handler, event_type, event_id, event_data, timestamp)\n            )\n            thread.daemon = True\n            thread.start()\n\ndef deliver_webhook(handler, event_type, event_id, event_data, timestamp):\n    """Deliver a webhook to its target URL"""\n    try:\n        webhook_id = handler["id"]  # Database ID\n        webhook_public_id = handler["webhook_id"]  # Public ID\n        target_url = handler["target_url"]\n        content_type = handler.get("content_type", "application/json")\n        \n        # Prepare payload\n        payload = json.dumps(event_data)\n        \n        # Generate signature\n        signature_payload = f"{int(timestamp.timestamp())}.{payload}"\n        \n        # In a real implementation, we would retrieve the actual secret\n        # For now, we\'ll use a placeholder\n        secret = "webhook_secret_would_be_retrieved_here"\n        \n        signature = hmac.new(\n            secret.encode(\'utf-8\'),\n            signature_payload.encode(\'utf-8\'),\n            hashlib.sha256\n        ).hexdigest()\n        \n        # Prepare headers\n        headers = {\n            "Content-Type": content_type,\n            "X-Prejudice-Signature": f"sha256={signature}",\n            "X-Prejudice-Timestamp": str(int(timestamp.timestamp())),\n            "X-Prejudice-Event": event_type,\n            "X-Prejudice-Webhook-ID": webhook_public_id,\n            "User-Agent": "PrejudiceRiskCalculator-Webhook/1.0"\n        }\n        \n        # Create delivery record\n        delivery = WebhookDelivery(\n            delivery_id=f"dlv_{str(uuid.uuid4())[:8]}",\n            webhook_id=webhook_id,\n            event_id=event_id,\n            event_type=event_type,\n            payload=payload,\n            status="pending",\n            created_at=timestamp,\n            updated_at=timestamp\n        )\n        \n        # In a real implementation, we would use a database session\n        # For now, we\'ll simulate the delivery\n        \n        # Send request\n        current_app.logger.info(f"Delivering webhook {webhook_public_id} for event {event_id} to {target_url}")\n        \n        # In a real implementation, this would actually send the request\n        # For now, we\'ll simulate a successful delivery\n        # response = requests.post(target_url, headers=headers, data=payload, timeout=10)\n        \n        # Simulate response\n        response_code = 200\n        response_body = \'{"status":"received"}\'\n        \n        # Update delivery record\n        delivery.status = "delivered" if response_code >= 200 and response_code < 300 else "failed"\n        delivery.response_code = response_code\n        delivery.response_body = response_body\n        delivery.updated_at = datetime.datetime.utcnow()\n        \n        if delivery.status == "delivered":\n            delivery.delivered_at = delivery.updated_at\n        else:\n            delivery.error = f"HTTP {response_code}"\n            # In a real implementation, this would schedule a retry\n        \n        current_app.logger.info(\n            f"Webhook {webhook_public_id} delivery {delivery.delivery_id} "\n            f"status: {delivery.status} ({response_code})"\n        )\n        \n        # In a real implementation, we would commit the delivery record\n        # db_session.add(delivery)\n        # db_session.commit()\n        \n    except Exception as e:\n        current_app.logger.exception(f"Error delivering webhook: {str(e)}")\n        # In a real implementation, we would update the delivery record with the error\n        # delivery.status = "failed"\n        # delivery.error = str(e)\n        # delivery.updated_at = datetime.datetime.utcnow()\n        # db_session.add(delivery)\n        # db_session.commit()\n\ndef retry_failed_deliveries():\n    """Retry failed webhook deliveries"""\n    try:\n        # In a real implementation, this would query the database for failed deliveries\n        # For now, we\'ll just log a message\n        current_app.logger.info("Retrying failed webhook deliveries")\n        \n    except Exception as e:\n        current_app.logger.exception(f"Error retrying failed deliveries: {str(e)}")\n</create-file>\n</function_calls>', 'tool_calls': None}