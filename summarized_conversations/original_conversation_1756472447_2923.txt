{'role': 'assistant', 'content': 'Let\'s create the assessments routes file:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/routes/assessments.py">\n"""\nRoutes for assessment management\n"""\n\nimport datetime\nimport uuid\nfrom flask import Blueprint, jsonify, request, current_app, g\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom werkzeug.exceptions import NotFound, BadRequest\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom models import Assessment, Factor, Result\nfrom utils.auth import require_api_key\nfrom utils.validation import validate_assessment_data\nfrom utils.events import trigger_event\n\n# Create blueprint\nassessments_bp = Blueprint(\'assessments\', __name__)\n\n# Initialize rate limiter\nlimiter = Limiter(key_func=get_remote_address)\n\ndef generate_assessment_id():\n    """Generate a unique assessment ID"""\n    year = datetime.datetime.now().year\n    # Get the count of assessments for this year\n    count = g.db_session.query(Assessment).filter(\n        Assessment.assessment_id.like(f"PRF-{year}-%")\n    ).count() + 1\n    return f"PRF-{year}-{count:04d}"\n\n@assessments_bp.route(\'\', methods=[\'POST\'])\n@require_api_key\n@limiter.limit("60 per minute")\ndef create_assessment():\n    """Create a new prejudice risk assessment"""\n    try:\n        # Validate request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        errors = validate_assessment_data(data)\n        if errors:\n            return jsonify({"errors": errors}), 400\n        \n        # Generate assessment ID\n        assessment_id = generate_assessment_id()\n        timestamp = datetime.datetime.utcnow()\n        \n        # Create assessment record\n        assessment = Assessment(\n            assessment_id=assessment_id,\n            case_name=data["case_name"],\n            judge_name=data["judge_name"],\n            assessor_name=data["assessor_name"],\n            assessment_date=datetime.datetime.strptime(data.get("assessment_date", timestamp.strftime("%Y-%m-%d")), "%Y-%m-%d"),\n            case_id=data.get("case_id", ""),\n            case_management_system_id=data.get("case_management_system_id", ""),\n            status="created",\n            created_at=timestamp,\n            updated_at=timestamp\n        )\n        \n        # Save to database\n        g.db_session.add(assessment)\n        g.db_session.commit()\n        \n        # Generate access token (in a real app, this would be a JWT)\n        access_token = str(uuid.uuid4())\n        \n        # Trigger event\n        trigger_event(\'assessment.created\', {\n            \'assessment_id\': assessment_id,\n            \'case_name\': assessment.case_name,\n            \'judge_name\': assessment.judge_name,\n            \'assessor_name\': assessment.assessor_name,\n            \'assessment_date\': assessment.assessment_date.isoformat(),\n            \'case_id\': assessment.case_id,\n            \'case_management_system_id\': assessment.case_management_system_id,\n            \'status\': assessment.status\n        })\n        \n        # Return response\n        return jsonify({\n            "assessment_id": assessment_id,\n            "status": "created",\n            "created_at": timestamp.isoformat(),\n            "access_token": access_token\n        }), 201\n        \n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error creating assessment: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error creating assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@assessments_bp.route(\'/<assessment_id>\', methods=[\'GET\'])\n@require_api_key\ndef get_assessment(assessment_id):\n    """Retrieve an existing assessment"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Convert to dictionary\n        assessment_dict = assessment.to_dict()\n        \n        # Add factors if available\n        factors = g.db_session.query(Factor).filter_by(assessment_id=assessment.id).all()\n        if factors:\n            factor_list = [factor.to_dict() for factor in factors]\n            assessment_dict["factors"] = factor_list\n        \n        # Add latest result if available\n        latest_result = assessment.latest_result\n        if latest_result:\n            assessment_dict["results"] = latest_result.to_dict()\n        \n        return jsonify(assessment_dict), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except Exception as e:\n        current_app.logger.exception(f"Error retrieving assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@assessments_bp.route(\'/<assessment_id>\', methods=[\'PUT\'])\n@require_api_key\ndef update_assessment(assessment_id):\n    """Update an existing assessment"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Get request data\n        data = request.get_json()\n        if not data:\n            raise BadRequest("No data provided")\n        \n        # Update assessment fields\n        timestamp = datetime.datetime.utcnow()\n        updated = False\n        \n        for field in ["case_name", "judge_name", "assessor_name", "case_id", "case_management_system_id"]:\n            if field in data:\n                setattr(assessment, field, data[field])\n                updated = True\n        \n        if "assessment_date" in data:\n            try:\n                assessment.assessment_date = datetime.datetime.strptime(data["assessment_date"], "%Y-%m-%d")\n                updated = True\n            except ValueError:\n                raise BadRequest("Invalid assessment_date format. Use YYYY-MM-DD")\n        \n        if updated:\n            assessment.updated_at = timestamp\n            assessment.status = "updated"\n            g.db_session.commit()\n            \n            # Trigger event\n            trigger_event(\'assessment.updated\', {\n                \'assessment_id\': assessment_id,\n                \'case_name\': assessment.case_name,\n                \'judge_name\': assessment.judge_name,\n                \'assessor_name\': assessment.assessor_name,\n                \'assessment_date\': assessment.assessment_date.isoformat(),\n                \'case_id\': assessment.case_id,\n                \'case_management_system_id\': assessment.case_management_system_id,\n                \'status\': assessment.status\n            })\n        \n        return jsonify({\n            "assessment_id": assessment_id,\n            "status": "updated",\n            "updated_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except BadRequest as e:\n        return jsonify({"error": str(e)}), 400\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error updating assessment: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error updating assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@assessments_bp.route(\'/<assessment_id>\', methods=[\'DELETE\'])\n@require_api_key\ndef delete_assessment(assessment_id):\n    """Delete an assessment"""\n    try:\n        # Query assessment\n        assessment = g.db_session.query(Assessment).filter_by(assessment_id=assessment_id).first()\n        if not assessment:\n            raise NotFound(f"Assessment {assessment_id} not found")\n        \n        # Delete assessment\n        timestamp = datetime.datetime.utcnow()\n        \n        # Trigger event before deletion\n        trigger_event(\'assessment.deleted\', {\n            \'assessment_id\': assessment_id,\n            \'deleted_at\': timestamp.isoformat()\n        })\n        \n        g.db_session.delete(assessment)\n        g.db_session.commit()\n        \n        return jsonify({\n            "status": "deleted",\n            "deleted_at": timestamp.isoformat()\n        }), 200\n        \n    except NotFound as e:\n        return jsonify({"error": str(e)}), 404\n    except SQLAlchemyError as e:\n        g.db_session.rollback()\n        current_app.logger.error(f"Database error deleting assessment: {str(e)}")\n        return jsonify({"error": "Database error"}), 500\n    except Exception as e:\n        g.db_session.rollback()\n        current_app.logger.exception(f"Error deleting assessment: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n\n@assessments_bp.route(\'\', methods=[\'GET\'])\n@require_api_key\n@limiter.limit("30 per minute")\ndef list_assessments():\n    """List assessments with filtering options"""\n    try:\n        # Get query parameters\n        page = int(request.args.get(\'page\', 1))\n        per_page = min(int(request.args.get(\'per_page\', 20)), 100)  # Limit to 100 items per page\n        case_name = request.args.get(\'case_name\')\n        judge_name = request.args.get(\'judge_name\')\n        status = request.args.get(\'status\')\n        \n        # Build query\n        query = g.db_session.query(Assessment)\n        \n        # Apply filters\n        if case_name:\n            query = query.filter(Assessment.case_name.ilike(f"%{case_name}%"))\n        if judge_name:\n            query = query.filter(Assessment.judge_name.ilike(f"%{judge_name}%"))\n        if status:\n            query = query.filter(Assessment.status == status)\n        \n        # Count total\n        total = query.count()\n        \n        # Paginate\n        query = query.order_by(Assessment.created_at.desc())\n        query = query.offset((page - 1) * per_page).limit(per_page)\n        \n        # Execute query\n        assessments = query.all()\n        \n        # Convert to dictionaries\n        assessment_list = [assessment.to_dict() for assessment in assessments]\n        \n        return jsonify({\n            "assessments": assessment_list,\n            "page": page,\n            "per_page": per_page,\n            "total": total,\n            "pages": (total + per_page - 1) // per_page  # Ceiling division\n        }), 200\n        \n    except ValueError as e:\n        return jsonify({"error": "Invalid pagination parameters"}), 400\n    except Exception as e:\n        current_app.logger.exception(f"Error listing assessments: {str(e)}")\n        return jsonify({"error": "Internal server error"}), 500\n</create-file>\n</function_calls>', 'tool_calls': None}