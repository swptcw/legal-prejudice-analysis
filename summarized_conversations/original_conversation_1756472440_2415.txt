{'role': 'assistant', 'content': 'Now, let\'s create a database models file to properly structure our data:\n\n<function_calls>\n<create-file file_path="prejudice_risk_calculator/production_setup/models.py">\n"""\nDatabase models for the Legal Prejudice Risk Calculator API\n"""\n\nfrom datetime import datetime\nimport uuid\nimport json\nfrom sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, ForeignKey, Text, JSON, Enum, UniqueConstraint\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nimport enum\n\nBase = declarative_base()\n\nclass RiskLevel(enum.Enum):\n    """Risk level enumeration"""\n    LOW = "Low"\n    MEDIUM = "Medium"\n    HIGH = "High"\n    CRITICAL = "Critical"\n\n\nclass Assessment(Base):\n    """Assessment model"""\n    __tablename__ = \'assessments\'\n    \n    id = Column(Integer, primary_key=True)\n    assessment_id = Column(String(20), unique=True, nullable=False, index=True)\n    case_name = Column(String(255), nullable=False)\n    judge_name = Column(String(255), nullable=False)\n    assessor_name = Column(String(255), nullable=False)\n    assessment_date = Column(DateTime, nullable=False, default=datetime.utcnow)\n    case_id = Column(String(100), nullable=True)\n    case_management_system_id = Column(String(100), nullable=True)\n    status = Column(String(50), nullable=False, default=\'created\')\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationships\n    factors = relationship("Factor", back_populates="assessment", cascade="all, delete-orphan")\n    results = relationship("Result", back_populates="assessment", cascade="all, delete-orphan")\n    cms_links = relationship("CMSLink", back_populates="assessment", cascade="all, delete-orphan")\n    \n    def __repr__(self):\n        return f"<Assessment {self.assessment_id}: {self.case_name}>"\n    \n    @property\n    def latest_result(self):\n        """Get the latest result for this assessment"""\n        if not self.results:\n            return None\n        return max(self.results, key=lambda r: r.calculated_at)\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'assessment_id\': self.assessment_id,\n            \'case_name\': self.case_name,\n            \'judge_name\': self.judge_name,\n            \'assessor_name\': self.assessor_name,\n            \'assessment_date\': self.assessment_date.isoformat(),\n            \'case_id\': self.case_id,\n            \'case_management_system_id\': self.case_management_system_id,\n            \'status\': self.status,\n            \'created_at\': self.created_at.isoformat(),\n            \'updated_at\': self.updated_at.isoformat()\n        }\n\n\nclass Factor(Base):\n    """Factor model for storing factor ratings"""\n    __tablename__ = \'factors\'\n    \n    id = Column(Integer, primary_key=True)\n    assessment_id = Column(Integer, ForeignKey(\'assessments.id\'), nullable=False)\n    factor_id = Column(String(100), nullable=False)\n    category = Column(String(100), nullable=False)\n    likelihood = Column(Integer, nullable=True)\n    impact = Column(Integer, nullable=True)\n    notes = Column(Text, nullable=True)\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationships\n    assessment = relationship("Assessment", back_populates="factors")\n    \n    # Constraints\n    __table_args__ = (\n        UniqueConstraint(\'assessment_id\', \'factor_id\', name=\'uix_factor_assessment\'),\n    )\n    \n    def __repr__(self):\n        return f"<Factor {self.factor_id} for Assessment {self.assessment.assessment_id}>"\n    \n    @property\n    def score(self):\n        """Calculate factor score"""\n        if self.likelihood is None or self.impact is None:\n            return None\n        return self.likelihood * self.impact\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'id\': self.factor_id,\n            \'category\': self.category,\n            \'likelihood\': self.likelihood,\n            \'impact\': self.impact,\n            \'score\': self.score,\n            \'notes\': self.notes,\n            \'created_at\': self.created_at.isoformat(),\n            \'updated_at\': self.updated_at.isoformat()\n        }\n\n\nclass Result(Base):\n    """Result model for storing risk calculation results"""\n    __tablename__ = \'results\'\n    \n    id = Column(Integer, primary_key=True)\n    assessment_id = Column(Integer, ForeignKey(\'assessments.id\'), nullable=False)\n    overall_score = Column(Float, nullable=False)\n    risk_level = Column(Enum(RiskLevel), nullable=False)\n    category_scores = Column(JSON, nullable=False)\n    high_risk_factors = Column(JSON, nullable=False)\n    recommendations = Column(JSON, nullable=False)\n    calculated_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    \n    # Relationships\n    assessment = relationship("Assessment", back_populates="results")\n    \n    def __repr__(self):\n        return f"<Result for Assessment {self.assessment.assessment_id}: {self.risk_level.value}>"\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'assessment_id\': self.assessment.assessment_id,\n            \'overall_score\': self.overall_score,\n            \'risk_level\': self.risk_level.value,\n            \'category_scores\': json.loads(self.category_scores) if isinstance(self.category_scores, str) else self.category_scores,\n            \'high_risk_factors\': json.loads(self.high_risk_factors) if isinstance(self.high_risk_factors, str) else self.high_risk_factors,\n            \'recommendations\': json.loads(self.recommendations) if isinstance(self.recommendations, str) else self.recommendations,\n            \'calculated_at\': self.calculated_at.isoformat()\n        }\n\n\nclass CMSLink(Base):\n    """CMS Link model for storing connections to case management systems"""\n    __tablename__ = \'cms_links\'\n    \n    id = Column(Integer, primary_key=True)\n    assessment_id = Column(Integer, ForeignKey(\'assessments.id\'), nullable=False)\n    cms_type = Column(String(100), nullable=False)\n    cms_case_id = Column(String(100), nullable=False)\n    cms_matter_id = Column(String(100), nullable=True)\n    sync_data = Column(Boolean, nullable=False, default=False)\n    linked_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationships\n    assessment = relationship("Assessment", back_populates="cms_links")\n    \n    def __repr__(self):\n        return f"<CMSLink {self.cms_type} for Assessment {self.assessment.assessment_id}>"\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'assessment_id\': self.assessment.assessment_id,\n            \'cms_type\': self.cms_type,\n            \'cms_case_id\': self.cms_case_id,\n            \'cms_matter_id\': self.cms_matter_id,\n            \'sync_data\': self.sync_data,\n            \'linked_at\': self.linked_at.isoformat(),\n            \'updated_at\': self.updated_at.isoformat()\n        }\n\n\nclass APIKey(Base):\n    """API Key model for authentication"""\n    __tablename__ = \'api_keys\'\n    \n    id = Column(Integer, primary_key=True)\n    key_id = Column(String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))\n    key_hash = Column(String(255), nullable=False)\n    name = Column(String(255), nullable=False)\n    description = Column(Text, nullable=True)\n    created_by = Column(String(255), nullable=False)\n    is_active = Column(Boolean, nullable=False, default=True)\n    last_used_at = Column(DateTime, nullable=True)\n    expires_at = Column(DateTime, nullable=True)\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    def __repr__(self):\n        return f"<APIKey {self.key_id}: {self.name}>"\n\n\nclass Webhook(Base):\n    """Webhook model for storing webhook configurations"""\n    __tablename__ = \'webhooks\'\n    \n    id = Column(Integer, primary_key=True)\n    webhook_id = Column(String(36), unique=True, nullable=False, default=lambda: f"wh_{str(uuid.uuid4())[:8]}")\n    target_url = Column(String(255), nullable=False)\n    events = Column(JSON, nullable=False)\n    description = Column(Text, nullable=True)\n    secret_hash = Column(String(255), nullable=False)\n    active = Column(Boolean, nullable=False, default=True)\n    content_type = Column(String(100), nullable=False, default=\'application/json\')\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relationships\n    deliveries = relationship("WebhookDelivery", back_populates="webhook", cascade="all, delete-orphan")\n    \n    def __repr__(self):\n        return f"<Webhook {self.webhook_id}: {self.target_url}>"\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'webhook_id\': self.webhook_id,\n            \'target_url\': self.target_url,\n            \'events\': json.loads(self.events) if isinstance(self.events, str) else self.events,\n            \'description\': self.description,\n            \'active\': self.active,\n            \'content_type\': self.content_type,\n            \'created_at\': self.created_at.isoformat(),\n            \'updated_at\': self.updated_at.isoformat()\n        }\n\n\nclass WebhookDelivery(Base):\n    """Webhook Delivery model for tracking webhook deliveries"""\n    __tablename__ = \'webhook_deliveries\'\n    \n    id = Column(Integer, primary_key=True)\n    delivery_id = Column(String(36), unique=True, nullable=False, default=lambda: f"dlv_{str(uuid.uuid4())[:8]}")\n    webhook_id = Column(Integer, ForeignKey(\'webhooks.id\'), nullable=False)\n    event_id = Column(String(36), nullable=False)\n    event_type = Column(String(100), nullable=False)\n    payload = Column(JSON, nullable=False)\n    status = Column(String(50), nullable=False, default=\'pending\')\n    response_code = Column(Integer, nullable=True)\n    response_body = Column(Text, nullable=True)\n    error = Column(Text, nullable=True)\n    retry_count = Column(Integer, nullable=False, default=0)\n    next_retry_at = Column(DateTime, nullable=True)\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    delivered_at = Column(DateTime, nullable=True)\n    \n    # Relationships\n    webhook = relationship("Webhook", back_populates="deliveries")\n    \n    def __repr__(self):\n        return f"<WebhookDelivery {self.delivery_id}: {self.status}>"\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'delivery_id\': self.delivery_id,\n            \'webhook_id\': self.webhook.webhook_id,\n            \'event_id\': self.event_id,\n            \'event_type\': self.event_type,\n            \'status\': self.status,\n            \'response_code\': self.response_code,\n            \'response_body\': self.response_body,\n            \'error\': self.error,\n            \'retry_count\': self.retry_count,\n            \'created_at\': self.created_at.isoformat(),\n            \'updated_at\': self.updated_at.isoformat(),\n            \'delivered_at\': self.delivered_at.isoformat() if self.delivered_at else None\n        }\n\n\nclass FactorDefinition(Base):\n    """Factor Definition model for storing factor definitions"""\n    __tablename__ = \'factor_definitions\'\n    \n    id = Column(Integer, primary_key=True)\n    factor_id = Column(String(100), unique=True, nullable=False)\n    name = Column(String(255), nullable=False)\n    category = Column(String(100), nullable=False)\n    description = Column(Text, nullable=True)\n    guidance = Column(Text, nullable=True)\n    created_at = Column(DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = Column(DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    def __repr__(self):\n        return f"<FactorDefinition {self.factor_id}: {self.name}>"\n    \n    def to_dict(self):\n        """Convert to dictionary"""\n        return {\n            \'id\': self.factor_id,\n            \'name\': self.name,\n            \'category\': self.category,\n            \'description\': self.description,\n            \'guidance\': self.guidance\n        }\n</create-file>\n</function_calls>', 'tool_calls': None}